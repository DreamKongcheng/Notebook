<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        
        
        
        <link rel="shortcut icon" href="../../../img/favicon.ico">
        <title>作业要点 - 我的第一个站点</title>
        <link href="../../../css/bootstrap.min.css" rel="stylesheet">
        <link href="../../../css/font-awesome.min.css" rel="stylesheet">
        <link href="../../../css/base.css" rel="stylesheet">
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/styles/github.min.css">
        <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.8.0/highlight.min.js"></script>
        <script>hljs.highlightAll();</script> 
    </head>

    <body>
        <div class="navbar fixed-top navbar-expand-lg navbar-dark bg-primary">
            <div class="container">
                <a class="navbar-brand" href="../../..">我的第一个站点</a>
                <!-- Expander button -->
                <button type="button" class="navbar-toggler" data-toggle="collapse" data-target="#navbar-collapse">
                    <span class="navbar-toggler-icon"></span>
                </button>

                <!-- Expanded navigation -->
                <div id="navbar-collapse" class="navbar-collapse collapse">
                        <!-- Main navigation -->
                        <ul class="nav navbar-nav">
                            <li class="navitem">
                                <a href="../../.." class="nav-link">Welcome to MkDocs</a>
                            </li>
                            <li class="dropdown active">
                                <a href="#" class="nav-link dropdown-toggle" data-toggle="dropdown">ZJU CS <b class="caret"></b></a>
                                <ul class="dropdown-menu">
                                    
<li>
    <a href="../../" class="dropdown-item">ZJU CS 课程</a>
</li>
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">DigitalDesign</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../DigitalDesign/" class="dropdown-item">[大二秋冬] 数字逻辑设计 | Digital Design</a>
</li>
            
<li>
    <a href="../../DigitalDesign/Chap01/" class="dropdown-item">Chap 1 Digital Systems and Information</a>
</li>
            
<li>
    <a href="../../DigitalDesign/Chap02/" class="dropdown-item">Chap 2 Combinational Logic Circuits</a>
</li>
            
<li>
    <a href="../../DigitalDesign/Chap03/" class="dropdown-item">Chap 3 Combinational Logic Design</a>
</li>
            
<li>
    <a href="../../DigitalDesign/Chap04/" class="dropdown-item">Chap 4 Sequential Circuits</a>
</li>
            
<li>
    <a href="../../DigitalDesign/Chap05/" class="dropdown-item">Chap 5 Digital Hardware Implementation</a>
</li>
            
<li>
    <a href="../../DigitalDesign/Chap06/" class="dropdown-item">Chap 6 Registers & Register Transfers</a>
</li>
            
<li>
    <a href="../../DigitalDesign/Chap07/" class="dropdown-item">Chap 7 Memory Basics</a>
</li>
            
<li>
    <a href="../../DigitalDesign/glossary/" class="dropdown-item">词汇表</a>
</li>
            
<li>
    <a href="../../DigitalDesign/learnskill/" class="dropdown-item">学习思路以及资源</a>
</li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">Discrete math</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../Discrete%20math/" class="dropdown-item">离散数学</a>
</li>
            
<li>
    <a href="../../Discrete%20math/note/" class="dropdown-item">摘要</a>
</li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">FDS</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../" class="dropdown-item">Index</a>
</li>
            
<li>
    <a href="../algorithm/" class="dropdown-item">算法分析</a>
</li>
            
<li>
    <a href="../exam/" class="dropdown-item">历年卷</a>
</li>
            
<li>
    <a href="../graph/" class="dropdown-item">图论</a>
</li>
            
<li>
    <a href="../hash/" class="dropdown-item">散列（哈希）</a>
</li>
            
<li>
    <a href="../heap/" class="dropdown-item">优先队列（堆）</a>
</li>
            
<li>
    <a href="./" class="dropdown-item active">作业要点</a>
</li>
            
<li>
    <a href="../set/" class="dropdown-item">并查集</a>
</li>
            
<li>
    <a href="../sort/" class="dropdown-item">排序</a>
</li>
            
<li>
    <a href="../tree/" class="dropdown-item">树</a>
</li>
            
<li>
    <a href="../%E6%95%B0%E7%BB%84%E4%B8%8E%E9%93%BE%E8%A1%A8/" class="dropdown-item">数组与链表</a>
</li>
            
<li>
    <a href="../%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/" class="dropdown-item">栈和队列</a>
</li>
    </ul>
  </li>
                                    
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">HPC</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../HPC/" class="dropdown-item">ZJUSCT</a>
</li>
            
<li>
    <a href="../../HPC/AIPP/" class="dropdown-item">并行计算设计导论</a>
</li>
            
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">Class</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../HPC/class/" class="dropdown-item">note of class</a>
</li>
            
<li>
    <a href="../../HPC/class/L1/" class="dropdown-item">7月4日 计算机体系结构和高性能计算基础</a>
</li>
            
<li>
    <a href="../../HPC/class/L2/" class="dropdown-item">7月5日 高性能计算方法论（HPC）</a>
</li>
            
<li>
    <a href="../../HPC/class/L3/" class="dropdown-item">7月6日 集群软硬件以及运维基础</a>
</li>
            
<li>
    <a href="../../HPC/class/L4/" class="dropdown-item">7月8日 向量化并行计算基础</a>
</li>
            
<li>
    <a href="../../HPC/class/L5/" class="dropdown-item">7月9日 GPU (Graphic Processing Unit)</a>
</li>
            
<li>
    <a href="../../HPC/class/L6/" class="dropdown-item">7月10日 OpenMP</a>
</li>
            
<li>
    <a href="../../HPC/class/L7/" class="dropdown-item">7月11号 机器学习（Machine Learning)</a>
</li>
            
<li>
    <a href="../../HPC/class/L8/" class="dropdown-item">高性能计算高级话术</a>
</li>
    </ul>
  </li>
            
  <li class="dropdown-submenu">
    <a href="#" class="dropdown-item">Homework</a>
    <ul class="dropdown-menu">
            
<li>
    <a href="../../HPC/homework/lab1/" class="dropdown-item">Lab-1</a>
</li>
            
<li>
    <a href="../../HPC/homework/lab2.5/" class="dropdown-item">Lab-2</a>
</li>
            
<li>
    <a href="../../HPC/homework/lab2/" class="dropdown-item">Lab2 向量化计算</a>
</li>
            
<li>
    <a href="../../HPC/homework/lab3/" class="dropdown-item">Lab-3 基于CUDA对GEMM的优化</a>
</li>
            
<li>
    <a href="../../HPC/homework/lab4/" class="dropdown-item">Lab-4 PCG算法在OMP和MPI下的优化</a>
</li>
            
<li>
    <a href="../../HPC/homework/lab5/" class="dropdown-item">Lab-5 AI相关</a>
</li>
    </ul>
  </li>
    </ul>
  </li>
                                </ul>
                            </li>
                        </ul>

                    <ul class="nav navbar-nav ml-auto">
                        <li class="nav-item">
                            <a href="#" class="nav-link" data-toggle="modal" data-target="#mkdocs_search_modal">
                                <i class="fa fa-search"></i> Search
                            </a>
                        </li>
                            <li class="nav-item">
                                <a rel="prev" href="../heap/" class="nav-link">
                                    <i class="fa fa-arrow-left"></i> Previous
                                </a>
                            </li>
                            <li class="nav-item">
                                <a rel="next" href="../set/" class="nav-link">
                                    Next <i class="fa fa-arrow-right"></i>
                                </a>
                            </li>
                    </ul>
                </div>
            </div>
        </div>

        <div class="container">
            <div class="row">
                    <div class="col-md-3"><div class="navbar-light navbar-expand-md bs-sidebar hidden-print affix" role="complementary">
    <div class="navbar-header">
        <button type="button" class="navbar-toggler collapsed" data-toggle="collapse" data-target="#toc-collapse" title="Table of Contents">
            <span class="fa fa-angle-down"></span>
        </button>
    </div>

    
    <div id="toc-collapse" class="navbar-collapse collapse card bg-secondary">
        <ul class="nav flex-column">
            
            <li class="nav-item" data-level="1"><a href="#_1" class="nav-link">作业要点</a>
              <ul class="nav flex-column">
            <li class="nav-item" data-level="2"><a href="#hw1-algorithm" class="nav-link">HW1 Algorithm</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#hw2-linked-list" class="nav-link">HW2 linked-list</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#hw3-stack-queue" class="nav-link">HW3 Stack &amp; Queue</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#hw4-binary-tree" class="nav-link">HW4 Binary tree</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#hw5" class="nav-link">HW5</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#hw6" class="nav-link">HW6</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#hw7" class="nav-link">HW7</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#hw8-graph" class="nav-link">HW8 Graph</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#hw9-shortest_path" class="nav-link">HW9 Shortest_Path</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#hw10-mst-maxstream" class="nav-link">HW10 MST &amp; Maxstream</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#hw11-dfs-insertionsort" class="nav-link">HW11 DFS &amp; InsertionSort</a>
              <ul class="nav flex-column">
              </ul>
            </li>
            <li class="nav-item" data-level="2"><a href="#hw12-sort" class="nav-link">HW12 sort</a>
              <ul class="nav flex-column">
              </ul>
            </li>
              </ul>
            </li>
        </ul>
    </div>
</div></div>
                    <div class="col-md-9" role="main">

<h1 id="_1">作业要点</h1>
<p>这里记录着所有homework中的要点，便于复习！（预习
[TOC]</p>
<h2 id="hw1-algorithm">HW1 Algorithm</h2>
<!-- prettier-ignore-start -->
<p>!!! Note "摘要"
    === "Knowledge"
        本节你需要学会基础的算法时间和空间复杂度的分析。</p>
<pre><code>=== "glossary"
    |英文|中文|
    |:--:|:--:|
    |complexity |复杂度 |
</code></pre>
<!-- prettier-ignore-end -->

<ol>
<li>The Fibonacci number sequence ${F_N}$ is defined as: $F_0 = 0$, $F_1=1$,$F_N=F_{N−1}+F_{N−2}, N=2, 3, ....$ The time complexity of the function which calculates $F_N$ recursively is Θ(N!).</li>
</ol>
<!-- prettier-ignore-start -->
<p>??? info "Tips"
    F</p>
<pre><code>在递归树中，每个节点表示一个递归调用，而树的深度表示递归的层数。对于斐波那契数列，每个节点会生成两个子节点，因为每个数都依赖于前两个数的和。

假设我们要计算第n个斐波那契数，递归树的深度将是n。每个节点的计算时间是常数时间，因为它只涉及到简单的加法操作。

因此，递归方法计算斐波那契数列的时间复杂度可以表示为O(2^n)。这是因为递归树的节点数是指数级增长的。
</code></pre>
<!-- prettier-ignore-end -->

<ol>
<li>$$ P_1:T(1) = 1, T(N) = T(N/3)+1\P_2:T(1) = 1, T(N) = 3T(N/3) $$</li>
</ol>
<p>求 $P_1, P_2$ 的复杂度</p>
<!-- prettier-ignore-start -->
<p>??? info "Tips"
    $O(logN)$ for P1, $O(N)$ for P2</p>
<!-- prettier-ignore-end -->

<h2 id="hw2-linked-list">HW2 linked-list</h2>
<!-- prettier-ignore-start -->
<p>!!! Note "摘要"
    === "Knowledge"
        本节你需要温习在之前C语言课程中对基础ADT的使用。熟练掌握链表的操作以及基本概念是非常有必要的。</p>
<pre><code>=== "glossary"
    |英文|中文|
    |:--:|:--:|
    |complexity |复杂度 |
</code></pre>
<!-- prettier-ignore-end -->

<ol>
<li><strong>Attention：</strong> Linear List（线性表）的初始定义是数组。</li>
<li>insertNode 函数可以背下来</li>
</ol>
<!-- prettier-ignore-start -->
<p>??? code "code"
    ```C
    void insertNode(struct Node<em> head, int Element) {
        // 创建新节点
        struct Node</em> newNode = (struct Node*)malloc(sizeof(struct Node));
        newNode-&gt;Element = Element;</p>
<pre><code>    newNode-&gt;Next = (head)-&gt;Next;
    (head)-&gt;Next = newNode;
}
```
</code></pre>
<!-- prettier-ignore-end -->
<ol>
<li>温习<code>`Mergesort</code>中merge的思想</li>
</ol>
<!-- prettier-ignore-start -->
<p>??? code "code"
    ```C</p>
<pre><code>#define type int
void Mergesort(type num[], int start, int end) {
    if (start &gt;= end) return;
    int mid = start + (end-start)/2;
    Mergesort(num, start, mid);
    Mergesort(num, mid+1, end);

    Merge(num, start, mid, end);
}

void Merge(int num[], int start, int mid, int end) {
    int* temp = (int*)malloc((end-start+1)*sizeof(type));
    int i = start;
    int j = mid + 1;
    int k = 0;
    while (i &lt;= mid &amp;&amp; j &lt;= end) {
        if (num[i] &lt;= num[j]){
            temp[k++] = num[i++];
        } else {
            temp[k++] = num[j++];
        }
    }
    while (i &lt;= mid) {
        temp[k++] = num[i++];
    }
    while (j &lt;= end) {
        temp[k++] = num[j++];
    }
}

```
</code></pre>
<!-- prettier-ignore-end -->

<h2 id="hw3-stack-queue">HW3 Stack &amp; Queue</h2>
<!-- prettier-ignore-start -->
<p>!!! Note "摘要"
    === "Knowledge"
        本节你需要温习在之前C语言课程中对基础ADT的使用。熟练掌握队列和栈。包括可以采用structue嵌套数组的方式来集成实现</p>
<pre><code>    编程题：OI里将这种思想归纳为“模拟”

=== "glossary"
    |英文|中文|
    |:--:|:--:|
    |front |前 |
    |rare |后 |
</code></pre>
<!-- prettier-ignore-end -->

<ol>
<li>stack pop <code>ooops</code>有多少种方式？   </li>
</ol>
<!-- prettier-ignore-start -->
<p>??? info "Tips"
    5
    笔者第一次做时粗糙的认为是4种。最后分析认为还是画类似树形流程图最为靠谱</p>
<!-- prettier-ignore-end -->

<ol>
<li>stack的一种集成方法</li>
</ol>
<pre><code class="language-C">//初始化时将top赋值为-1
typedef struct {
    int stack[MAX_SIZE];
    int top;
} Stack;

void push(Stack *s, int num) {
    s-&gt;stack[++s-&gt;top] = num;
}

int pop(Stack *s) {
    return s-&gt;stack[s-&gt;top--];
}
</code></pre>
<ol>
<li>Suppose that an array of size 6 is used to store a circular queue, and the values of front and rear are 0 and 4, respectively. Now after 2 dequeues and 2 enqueues, what will the values of front and rear be?</li>
</ol>
<!-- prettier-ignore-start -->
<p>??? info "Tips"
    [] Unfinished!
    2 0</p>
<!-- prettier-ignore-end -->

<h2 id="hw4-binary-tree">HW4 Binary tree</h2>
<!-- prettier-ignore-start -->
<p>!!! Note "摘要"
    === "Knowledge"
        本节你需要学习二叉树的一些基础概念与操作。</p>
<pre><code>    函数题充分展现了递归思想，编程题是对之前知识的综合使用

=== "glossary"
    |中文|英文|概念|
    |:--:|:--:|:--:|
    |根节点|root node|位于二叉树顶层的节点，没有父节点|
    |叶节点|leaf node|没有子节点的节点，其两个指针均指向| 
    |边|edge|连接两个节点的线段，即节点引用（指针）|
    |层|level|从顶至底递增，根节点所在层为 1 |
    |度|degree|节点的子节点的数量。在二叉树中，度的取值范围是 0、1、2 |
    |高度|height|从根节点到最远叶节点所经过的边的数量|
    |深度|depth|从根节点到该节点所经过的边的数量|
    |高度|height|从距离该节点最远的叶节点到该节点所经过的边的数量|
    |遍历|traversal| |
</code></pre>
<!-- prettier-ignore-end -->

<p>下面先让我们看看基本概念吧（From hello-algo）</p>
<!-- prettier-ignore-start -->
<p>??? info "二叉树基本概念"
    === "完美二叉树 perfect BT"
        <img alt="" src="../graph/pbt.png" />
    === "平衡二叉树 balance BT"
        <img alt="" src="../graph/bbt.png" />
    === "完全二叉树 complete BT"
        <img alt="" src="../graph/cbt.png" />
    ===  "完满二叉树 full BT"
        <img alt="" src="../graph/fbt.png" /></p>
<!-- prettier-ignore-end -->

<ol>
<li>There exists a binary tree with 2016 nodes in total, and with 16 nodes having only one child.</li>
</ol>
<!-- prettier-ignore-start -->
<p>??? info "Tips"
    F 本题是个脑经急转弯题目</p>
<!-- prettier-ignore-end -->

<ol>
<li>Given a tree of degree 3. Suppose that there are 3 nodes of degree 2 and 2 nodes of degree 3. Then the number of leaf nodes must be ____.</li>
</ol>
<!-- prettier-ignore-start -->
<p>??? info "Tips"
    8</p>
<pre><code>通解：
1. 算儿子， $ 3n_3+2n_2+n_1+1=N $
2. 算所有， $ n_3+n_2+n_1+n_0=N $

需要注意的概念：
结点的度（Degree）：结点的子树个数
树的度：树的所有结点中最大的degree
</code></pre>
<!-- prettier-ignore-end -->

<ol>
<li>If a general tree T is converted into a binary tree BT, then which of the following BT traversals gives the same sequence as that of the post-order traversal of T?</li>
</ol>
<!-- prettier-ignore-start -->

<p>??? info "Tips"
    <a href="https://blog.csdn.net/best_LY/article/details/121346561">普通树转二叉树</a></p>
<pre><code>可以这样浅显的理解：
1. 在所有兄弟节点间添加一条连线
2. 对每个节点，除了保留与第一个儿子的连线外，删除别的连线。
![](graph/nttbt.png)
</code></pre>
<!-- prettier-ignore-end -->

<p>!!! Note "conclusion"
    T的preorder = BT的preorder
    T的postorder = BT的inorder</p>
<ol>
<li>
<p>Threaded Binary Trees(一种对二叉树的优化，老师不讲但要掌握) 
!!! Note 
    <a href="../tree/#实现">线索二叉树</a></p>
<p>一个直观的快速解题的方法便是写出原本树的遍历结果，然后用使用左右指针与它的前后值接起来即可！</p>
</li>
</ol>
<h2 id="hw5">HW5</h2>
<ol>
<li>In a binary search tree which contains several integer keys including 4, 5, and 6, if 4 and 6 are on the same level, then 5 must be their parent.</li>
</ol>
<!-- prettier-ignore-start -->
<p>??? info "Tips"
    F 5 could be their grandparents</p>
<!-- prettier-ignore-end -->
<ol>
<li>2-3<!-- prettier-ignore-start -->
!!! note "Question"
    <img alt="" src="../graph/tree_Q1.png" /></li>
</ol>
<!-- prettier-ignore-end -->
<ol>
<li>什么是decision tree?</li>
<li>A binary search tree if ood nodes, 如果我们选<code>i/2</code>，之后每次都选<code>i/2</code>；选<code>i/2+1</code>则都选<code>i/2+1</code>。</li>
</ol>
<h2 id="hw6">HW6</h2>
<ol>
<li>heap两种插入方式，具体可见hello算法书</li>
<li>编程题有序数字串建完全二叉树可以利用中序历遍的思想来建树</li>
<li>红黑树？</li>
</ol>
<h2 id="hw7">HW7</h2>
<ol>
<li>In Union/Find algorithm, if Unions are done by size, the depth of any node must be no more than $N/2$ , but not $O(logN)$.</li>
</ol>
<!-- prettier-ignore-start -->
<p>??? info "Tips"
    F 假设最初每个节点的深度都为0，那么在进行N-1次按大小合并后，每个节点的深度最多为1。因此，任意节点的深度不会超过N/2。
    需要注意的是，这个结论是在按大小合并的情况下成立的。如果使用其他合并策略，例如按秩合并（将深度较小的树合并到深度较大的树中），那么节点的深度可能会更小，甚至可能达到O(logN)。</p>
<!-- prettier-ignore-end -->

<ol>
<li>The array representation of a disjoint set containing numbers 0 to 8 is given by { 1, -4, 1, 1, -3, 4, 4, 8, -2 }. Then to union the two sets which contain 6 and 8 (with union-by-size), the index of the resulting root and the value stored at the root are:</li>
</ol>
<!-- prettier-ignore-start -->
<p>??? info "Tips"
    4 -5</p>
<!-- prettier-ignore-end -->

<ol>
<li>Let T be a tree created by union-by-size with N nodes, then the height of T can be .</li>
</ol>
<!-- prettier-ignore-start -->
<p>??? info "Tips"
    at most $log(N) + 1$</p>
<!-- prettier-ignore-end -->

<ol>
<li>A relation R is defined on a set S. If for every element e in S, "e R e" is always true, then R is said to be <strong>reflexive</strong> over S.</li>
</ol>
<h2 id="hw8-graph">HW8 Graph</h2>
<blockquote>
<ol>
<li>图论中的degree是指与该节点所连接的边的个数
   By contrast， 树中的degree是指子节点的个数</li>
<li>In a connected graph, the number of edges must be equal or greater than the number of vertices minus 1.</li>
<li>A graph with 90 vertices and 20 edges must have at least __ connected component(s)</li>
</ol>
</blockquote>
<!-- prettier-ignore-start -->
<p>??? info "Tips"
    70</p>
<!-- prettier-ignore-end -->

<h2 id="hw9-shortest_path">HW9 Shortest_Path</h2>
<ol>
<li>Let P be the shortest path from S to T. If the weight of every edge in the graph is incremented by 2, P will still be the shortest path from S to T.</li>
</ol>
<!-- prettier-ignore-start -->
<p>!!! Note "key"
    F</p>
<pre><code>Because if shortest road has 6 nodes with 12 while 2nd-shortest road has 4 nodes with 13. After every edge incremented by 2. The last shortest road is 24 while last 2nd-shortest road is 21 which means it is the current shortest road!
</code></pre>
<!-- prettier-ignore-end -->

<ol>
<li>Use Dijkstra algorithm to find the shortest paths from 1 to every other vertices. In which order that the destinations must be obtained?</li>
</ol>
<h2 id="hw10-mst-maxstream">HW10 MST &amp; Maxstream</h2>
<blockquote>
<p>[x] Finished
本次作业，你需要对最小生成树（minimum spanning tree）的两个算法清晰的记忆，关于最大流应当学会计算。
1. The minimum spanning tree of any weighted graph ____</p>
</blockquote>
<!-- prettier-ignore-start -->
<p>??? info "Tips"
    May not exits.<br />
    Exit if it is connected.</p>
<!-- prettier-ignore-end -->

<ol>
<li>An example question about max stream.</li>
</ol>
<!-- prettier-ignore-start -->
<p>??? info "Question"
    <img alt="" src="../graph/Snipaste_2023-12-05_08-29-25.png" /></p>
<!-- prettier-ignore-end -->

<h2 id="hw11-dfs-insertionsort">HW11 DFS &amp; InsertionSort</h2>
<!-- prettier-ignore-start -->
<p>!!! Note "摘要"
    === "Knowledge"
        [] finshed?
        1. 本节需要掌握'biconnected"(<a href="https://www.cnblogs.com/bless/archive/2008/07/30/1256875.html">重连接</a>)相关的知识
        2. u is an articulation point if
        &gt; (1)  u is the root and has at least 2 children;  or
        &gt; (2)  u is not the root, and has at least 1 child such that  $Low(child) \ge Num(u)$
        3. Euler circuit: 简单来说就是“一笔画”问题，可看<a href="https://discrete.openmathbooks.org/dmoi2/sec_paths.html">Eular path</a>
        4. 以及你需要对dfs以及排序有熟练掌握（相信学到这里应该没有不熟练的了吧hhhh</p>
<pre><code>=== "glossary"
    |英文|中文|
    |:--:|:--:|  
    |articulation point |关节点 |
    |biconnected | 重联通|
</code></pre>
<!-- prettier-ignore-end -->

<ol>
<li>For a graph, if each vertex has an even degree or only two vertexes have odd degree, we can find a cycle that visits every edge exactly once</li>
</ol>
<!-- prettier-ignore-start -->
<p>??? info "Tips"
    F</p>
<pre><code>It has to be a Euler Cycle, thus only if each vertex has even degrees；Euler Circuit -&gt; exact 2 vertices have odd degrees / all vertices have even degrees
</code></pre>
<!-- prettier-ignore-end -->

<ol>
<li>Apply DFS to a directed acyclic graph, and output the vertex before the end of each recursion. The output sequence will be:</li>
</ol>
<!-- prettier-ignore-start -->
<p>??? info "Tips"
    acyclic graph -&gt; 无环图</p>
<!-- prettier-ignore-end -->

<ol>
<li>Graph G is an undirected completed graph of 20 nodes. Is there an Euler circuit in G? If not, in order to have an Euler circuit, what is the minimum number of edges which should be removed from G?</li>
</ol>
<!-- prettier-ignore-start -->
<p>??? info "Tips"
    Each Node has exactly 19 degrees</p>
<pre><code>- Euler Circuit (Strong Form) requires every node to be even degrees

- Euler Tour (Weak Form) requires 0 or 2 odd degrees

Remove 1 edge, every 2 nodes will lose 1 degrees, so we lose 10 edges
</code></pre>
<!-- prettier-ignore-end -->

<h2 id="hw12-sort">HW12 sort</h2>
<!-- prettier-ignore-start -->
<p>!!! note "摘要"
    === "Knowledge"
        本节你将学习到各种排序算法的思想以及实现。并且需要掌握各种排序算法的时间复杂度以及空间复杂度。</p>
<pre><code>    其中值得注意的是shell sort和heap sort的实现，以及对于quick sort的理解。
</code></pre>
<!-- prettier-ignore-end -->
<ol>
<li>Shellsort的实现如下：</li>
</ol>
<!-- prettier-ignore-start -->
<p>??? code "Shellsort"</p>
<pre><code>```C
// Shellsort
void Shellsort( ElementType A[ ], int N ) 
{ 
    int  i, j, Increment; 
    ElementType  Tmp; 
    for ( Increment = N / 2; Increment &gt; 0; Increment /= 2 )  
    /*h sequence */
    for ( i = Increment; i &lt; N; i++ ) { /* insertion sort */
        Tmp = A[ i ]; 
        for ( j = i; j &gt;= Increment; j - = Increment ) 
        if( Tmp &lt; A[ j - Increment ] ) 
            A[ j ] = A[ j - Increment ]; 
        else 
            break; 
        A[ j ] = Tmp; 
    } /* end for-I and for-Increment loops */
}
```
</code></pre>
<!-- prettier-ignore-end -->

<ol>
<li>Heapsort的实现如下：</li>
</ol>
<!-- prettier-ignore-start -->
<p>??? code "Heapsort"</p>
<pre><code>```C
void PercDown( ElementType A[ ], int i, int N ) 
{ 
    int  Child; 
    ElementType  Tmp; 
    for ( Tmp = A[ i ]; LeftChild( i ) &lt; N; i = Child ) { 
        Child = LeftChild( i ); 
        if( Child != N - 1 &amp;&amp; A[ Child + 1 ] &gt; A[ Child ] ) 
            Child++; 
        if( Tmp &lt; A[ Child ] ) 
            A[ i ] = A[ Child ]; 
        else 
            break; 
    } 
    A[ i ] = Tmp; 
}

void Heapsort( ElementType A[ ], int N ) 
{ 
    int  i; 
    for ( i = N / 2; i &gt;= 0; i-- ) /* BuildHeap */
        PercDown( A, i, N ); 
    for ( i = N - 1; i &gt; 0; i-- ) { 
        Swap( &amp;A[ 0 ], &amp;A[ i ] ); /* DeleteMax */
        PercDown( A, 0, i ); 
    } 
}
```
</code></pre></div>
            </div>
        </div>

        <footer class="col-md-12">
            <hr>
            <p>Documentation built with <a href="https://www.mkdocs.org/">MkDocs</a>.</p>
        </footer>
        <script src="../../../js/jquery-3.6.0.min.js"></script>
        <script src="../../../js/bootstrap.min.js"></script>
        <script>
            var base_url = "../../..",
                shortcuts = {"help": 191, "next": 78, "previous": 80, "search": 83};
        </script>
        <script src="../../../js/base.js"></script>
        <script src="../../../search/main.js"></script>

        <div class="modal" id="mkdocs_search_modal" tabindex="-1" role="dialog" aria-labelledby="searchModalLabel" aria-hidden="true">
    <div class="modal-dialog modal-lg">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="searchModalLabel">Search</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
                <p>From here you can search these documents. Enter your search terms below.</p>
                <form>
                    <div class="form-group">
                        <input type="search" class="form-control" placeholder="Search..." id="mkdocs-search-query" title="Type search term here">
                    </div>
                </form>
                <div id="mkdocs-search-results" data-no-results-text="No results found"></div>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div><div class="modal" id="mkdocs_keyboard_modal" tabindex="-1" role="dialog" aria-labelledby="keyboardModalLabel" aria-hidden="true">
    <div class="modal-dialog">
        <div class="modal-content">
            <div class="modal-header">
                <h4 class="modal-title" id="keyboardModalLabel">Keyboard Shortcuts</h4>
                <button type="button" class="close" data-dismiss="modal"><span aria-hidden="true">&times;</span><span class="sr-only">Close</span></button>
            </div>
            <div class="modal-body">
              <table class="table">
                <thead>
                  <tr>
                    <th style="width: 20%;">Keys</th>
                    <th>Action</th>
                  </tr>
                </thead>
                <tbody>
                  <tr>
                    <td class="help shortcut"><kbd>?</kbd></td>
                    <td>Open this help</td>
                  </tr>
                  <tr>
                    <td class="next shortcut"><kbd>n</kbd></td>
                    <td>Next page</td>
                  </tr>
                  <tr>
                    <td class="prev shortcut"><kbd>p</kbd></td>
                    <td>Previous page</td>
                  </tr>
                  <tr>
                    <td class="search shortcut"><kbd>s</kbd></td>
                    <td>Search</td>
                  </tr>
                </tbody>
              </table>
            </div>
            <div class="modal-footer">
            </div>
        </div>
    </div>
</div>

    </body>
</html>
